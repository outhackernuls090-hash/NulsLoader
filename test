-- delta_webhook_debug.lua
-- Run in your executor (Delta). Replace WEBHOOK to test real delivery.
local HttpService = game:GetService("HttpService")
local WEBHOOK = "https://discord.com/api/webhooks/1407814443231871226/doFyO0sPxeH5WFjvWgW0UlKDgjG6xAuBAvXjBAffh88jLaccLjOpsg32cKqBAp1y8iWq" -- replace to test real webhook
local HTTPBIN = "https://httpbin.org/post"

local function getRequester()
    -- return function(opts) -> ok, res, used
    if type(syn) == "table" and type(syn.request) == "function" then
        return function(opts) local ok,res = pcall(function() return syn.request(opts) end) return ok,res,"syn.request" end
    end
    if type(http_request) == "function" then
        return function(opts) local ok,res = pcall(function() return http_request(opts) end) return ok,res,"http_request" end
    end
    if type(http) == "table" and type(http.request) == "function" then
        return function(opts) local ok,res = pcall(function() return http.request(opts) end) return ok,res,"http.request" end
    end
    if type(request) == "function" then
        return function(opts) local ok,res = pcall(function() return request(opts) end) return ok,res,"request" end
    end
    if HttpService and type(HttpService.RequestAsync) == "function" then
        return function(opts)
            local ok,res = pcall(function()
                return HttpService:RequestAsync({
                    Url = opts.Url,
                    Method = opts.Method or "GET",
                    Headers = opts.Headers,
                    Body = opts.Body
                })
            end)
            return ok,res,"HttpService:RequestAsync"
        end
    end
    return nil
end

local requester = getRequester()
if not requester then
    warn("No HTTP requester detected in this executor.")
    return
end

local function short(s)
    s = tostring(s or "")
    if #s > 400 then return s:sub(1,400) .. "...(snip)" end
    return s
end

local function tryAttempt(label, opts)
    print("\n--- Attempt:", label, "using", opts._note or "no note")
    local ok, res, used = requester(opts)
    print(" used API:", tostring(used))
    if not ok then
        print(" call failed, error:", tostring(res))
        return { ok = false, used = used, err = res }
    end
    -- inspect response
    if type(res) == "table" then
        local status = res.StatusCode or res.status or res.code or res.Status
        local body = res.Body or res.body or res[1]
        print(" status:", tostring(status))
        print(" body snippet:", short(body))
        return { ok = true, used = used, status = status, body = body, raw = res }
    else
        print(" response (raw):", short(res))
        return { ok = true, used = used, status = nil, body = tostring(res), raw = res }
    end
end

-- Build a typical Discord embed payload
local payload = {
    content = "Test message from Delta debug script",
    embeds = {{
        title = "Delta Debug",
        description = "Testing POST formats",
        fields = {
            { name = "Executor guess", value = (identifyexecutor and pcall(identifyexecutor) and identifyexecutor() or "unknown"), inline = true },
            { name = "Time", value = os.date("%Y-%m-%d %H:%M:%S"), inline = true },
        }
    }}
}

local headers = { ["Content-Type"] = "application/json" }

local attempts = {}

-- 1) Test httpbin with JSON-string body
table.insert(attempts, { label = "httpbin JSON-string", Url = HTTPBIN, Method = "POST", Headers = headers, Body = HttpService:JSONEncode(payload), _note = "Body = JSON string" })

-- 2) Test httpbin with Body as table (for APIs that want table)
table.insert(attempts, { label = "httpbin body-table", Url = HTTPBIN, Method = "POST", Headers = headers, Body = payload, _note = "Body = table" })

-- 3) Test webhook with JSON-string body + wait param
table.insert(attempts, { label = "webhook JSON-string wait", Url = WEBHOOK .. "?wait=true", Method = "POST", Headers = headers, Body = HttpService:JSONEncode(payload), _note = "Discord webhook wait=true (JSON string)" })

-- 4) Test webhook with JSON-string direct (no wait)
table.insert(attempts, { label = "webhook JSON-string", Url = WEBHOOK, Method = "POST", Headers = headers, Body = HttpService:JSONEncode(payload), _note = "Discord webhook JSON string" })

-- 5) Test webhook with Body as table (some APIs accept this)
table.insert(attempts, { label = "webhook body-table", Url = WEBHOOK, Method = "POST", Headers = headers, Body = payload, _note = "body table" })

-- 6) Try urlencoded fallback (some executors prefer form-encoded)
local formBody = "content=" .. HttpService:UrlEncode("Test via form-encoded")
local headersForm = { ["Content-Type"] = "application/x-www-form-urlencoded" }
table.insert(attempts, { label = "webhook form-encoded", Url = WEBHOOK, Method = "POST", Headers = headersForm, Body = formBody, _note = "form-encoded content" })

-- 7) Try GET fallback to httpbin (just to see if GET works)
table.insert(attempts, { label = "httpbin GET", Url = HTTPBIN, Method = "GET", Headers = {}, Body = nil, _note = "GET to httpbin" })

-- run attempts and collect results
local results = {}
for i, a in ipairs(attempts) do
    local r = tryAttempt(a.label, a)
    results[a.label] = r
    task.wait(0.2)
end

print("\n=== Summary ===")
for k,v in pairs(results) do
    print(k, "=> ok:", tostring(v.ok), " used:", tostring(v.used), " status:", tostring(v.status), " err:", (v.err and tostring(v.err) or "nil"))
end

print("\nIf httpbin POSTs fail but GET works, Delta likely blocks outbound POSTs (or TLS for POST).")
print("If httpbin works but webhook attempts show 4xx/5xx or returned body says '401' or 'invalid webhook', check webhook URL or permissions.")
print("Paste the entire console output here and I'll tell you the exact next step.")
